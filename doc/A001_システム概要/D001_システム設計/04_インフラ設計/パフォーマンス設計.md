# パフォーマンス設計
## AI駆動開発調査プロジェクト - Web社員管理システム

**文書管理情報**
- 作成日: 2025-08-21
- バージョン: 1.0
- 作成者: AI駆動開発チーム
- 承認者: -
- 最終更新日: 2025-08-21

---

## 1. フロントエンド最適化

### 1.1. コード分割（Code Splitting）
```typescript
// ルートベースの遅延読み込み
const EmployeeListPage = lazy(() => import('../pages/EmployeeListPage'));
const DashboardPage = lazy(() => import('../pages/DashboardPage'));

// コンポーネントレベルの分割
const HeavyChart = lazy(() => import('../components/HeavyChart'));
```

**効果**:
- 初期ロード時間の短縮
- 必要な機能のみロード
- バンドルサイズの最適化

### 1.2. 画像最適化
- **WebP形式の使用**: ファイルサイズ20-35%削減
- **遅延読み込み（Lazy Loading）**: 初期表示の高速化
- **レスポンシブ画像**: デバイスに応じた最適化

```typescript
// 遅延読み込みの実装例
const LazyImage: React.FC<Props> = ({ src, alt }) => {
  const [loaded, setLoaded] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        setLoaded(true);
        observer.disconnect();
      }
    });

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <img
      ref={imgRef}
      src={loaded ? src : placeholderSrc}
      alt={alt}
      loading="lazy"
    />
  );
};
```

### 1.3. バンドル最適化
- **Tree Shaking**: 未使用コードの除去
- **動的インポート**: 必要時のみモジュール読み込み
- **圧縮**: Gzip/Brotli による配信最適化

```javascript
// Vite設定例
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
          ui: ['@headlessui/react'],
        },
      },
    },
  },
});
```

---

## 2. バックエンド最適化

### 2.1. データベースクエリ最適化

#### Eager Loading による N+1 問題対策
```php
// 悪い例（N+1問題）
$employees = Employee::all();
foreach ($employees as $employee) {
    echo $employee->department->name; // 各従業員ごとにクエリ実行
}

// 良い例（Eager Loading）
$employees = Employee::with(['department', 'position'])->get();
foreach ($employees as $employee) {
    echo $employee->department->name; // 1回のクエリで関連データ取得
}
```

#### インデックスの活用
```sql
-- 検索頻度の高いカラムにインデックス作成
CREATE INDEX idx_employees_department ON employees(department_id);
CREATE INDEX idx_employees_status ON employees(employment_status);
CREATE INDEX idx_employees_search ON employees(last_name, first_name);
```

### 2.2. キャッシュ戦略

#### Redis を使用したクエリキャッシュ
```php
class EmployeeService
{
    public function getDepartmentStats(): array
    {
        return Cache::remember('department_stats', 3600, function () {
            return Department::withCount('employees')
                ->where('is_active', true)
                ->get()
                ->toArray();
        });
    }
    
    public function getEmployeeById(int $id): Employee
    {
        return Cache::remember("employee_{$id}", 1800, function () use ($id) {
            return Employee::with(['department', 'position'])->findOrFail($id);
        });
    }
}
```

#### キャッシュ無効化戦略
```php
class EmployeeService
{
    public function updateEmployee(int $id, array $data): Employee
    {
        $employee = Employee::findOrFail($id);
        $employee->update($data);
        
        // 関連キャッシュの無効化
        Cache::forget("employee_{$id}");
        Cache::forget('department_stats');
        
        return $employee;
    }
}
```

### 2.3. ページネーション
```php
// 効率的なページネーション
class EmployeeController extends Controller
{
    public function index(Request $request): JsonResponse
    {
        $employees = Employee::with(['department', 'position'])
            ->when($request->search, function ($query) use ($request) {
                return $query->where('first_name', 'like', "%{$request->search}%")
                           ->orWhere('last_name', 'like', "%{$request->search}%");
            })
            ->paginate($request->per_page ?? 15);
            
        return EmployeeResource::collection($employees)->response();
    }
}
```

---

## 3. インフラ最適化

### 3.1. 静的ファイル配信
```nginx
# Nginx設定例
server {
    location ~* \.(css|js|png|jpg|jpeg|gif|svg|woff2?)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary Accept-Encoding;
        
        # Gzip圧縮
        gzip on;
        gzip_types text/css application/javascript image/svg+xml;
    }
    
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
}
```

### 3.2. データベース最適化

#### MySQL設定最適化
```ini
# my.cnf 設定例
[mysqld]
innodb_buffer_pool_size = 1G
innodb_log_file_size = 256M
innodb_flush_log_at_trx_commit = 2
query_cache_type = 1
query_cache_size = 128M
```

#### 接続プール設定
```php
// config/database.php
'mysql' => [
    'driver' => 'mysql',
    'options' => [
        PDO::ATTR_PERSISTENT => true,  // 永続的接続
    ],
    'pool' => [
        'min_connections' => 5,
        'max_connections' => 20,
    ],
],
```

### 3.3. 監視・アラート

#### Laravel Telescope による監視
```php
// config/telescope.php
'watchers' => [
    Watchers\QueryWatcher::class => [
        'enabled' => env('TELESCOPE_QUERY_WATCHER', true),
        'slow' => 100, // 100ms以上のクエリを記録
    ],
    
    Watchers\RequestWatcher::class => [
        'enabled' => env('TELESCOPE_REQUEST_WATCHER', true),
        'size_limit' => 64, // KB
    ],
],
```

#### パフォーマンス計測
```php
class PerformanceMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $start = microtime(true);
        
        $response = $next($request);
        
        $duration = microtime(true) - $start;
        
        // 500ms以上のリクエストをログ出力
        if ($duration > 0.5) {
            Log::warning('Slow request detected', [
                'url' => $request->fullUrl(),
                'method' => $request->method(),
                'duration' => $duration,
                'memory_usage' => memory_get_peak_usage(true),
            ]);
        }
        
        return $response;
    }
}
```

---

## 4. パフォーマンス目標値

### 4.1. レスポンス時間目標
| 処理種別 | 目標時間 | 許容時間 |
|----------|----------|----------|
| ページ初期表示 | < 2秒 | < 3秒 |
| API レスポンス | < 500ms | < 1秒 |
| 検索処理 | < 1秒 | < 2秒 |
| CSV インポート | < 30秒（1000件） | < 60秒 |

### 4.2. スループット目標
- 同時ユーザー数: 100人
- リクエスト/秒: 50 RPS
- データベース接続数: 最大20接続

### 4.3. リソース使用量目標
- CPU使用率: 平均 < 50%
- メモリ使用量: < 2GB
- ディスク使用量: < 80%

---

## 5. パフォーマンステスト

### 5.1. 負荷テスト
```bash
# Apache Bench による負荷テスト
ab -n 1000 -c 10 http://localhost/api/employees

# wrk による負荷テスト
wrk -t4 -c100 -d30s http://localhost/api/employees
```

### 5.2. フロントエンド パフォーマンステスト
```javascript
// Lighthouse CI設定
module.exports = {
  ci: {
    collect: {
      numberOfRuns: 3,
      url: ['http://localhost:3000/'],
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.8 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.8 }],
      },
    },
  },
};
```

### 5.3. データベース パフォーマンステスト
```sql
-- スロークエリ分析
SET long_query_time = 1;
SHOW VARIABLES LIKE 'slow_query_log';

-- インデックス使用状況確認
EXPLAIN SELECT * FROM employees 
WHERE department_id = 1 
AND employment_status = 'active';
```

---

## 6. 継続的パフォーマンス改善

### 6.1. 監視指標
- **アプリケーション指標**: レスポンス時間、エラー率
- **インフラ指標**: CPU、メモリ、ディスク使用率
- **ユーザー体験指標**: ページ読み込み時間、離脱率

### 6.2. 改善プロセス
1. **測定**: 定期的なパフォーマンス測定
2. **分析**: ボトルネックの特定
3. **最適化**: 対策の実装
4. **検証**: 改善効果の確認

### 6.3. アラート設定
```yaml
# Prometheus アラート設定例
groups:
  - name: application
    rules:
      - alert: HighResponseTime
        expr: avg_response_time > 1000
        labels:
          severity: warning
        annotations:
          summary: "API response time is too high"
```

---

**備考**: 本設計書はAI駆動開発の調査目的で作成されており、実装過程で得られた知見により適宜更新される予定です。パフォーマンス要件は実際の負荷に応じて調整します。